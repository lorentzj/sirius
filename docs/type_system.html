<!DOCTYPE HTML>
<html>
    <head>
        <meta charset = "UTF-8">
        <link rel="icon" type="image/x-icon" href="./favicon.ico">
        <link rel = "stylesheet" href = "./css/main.css">
        <script src = "./js/docs.js" type = "module"></script>
        <title>Sirius</title>
    </head>
    <body>
        <article>
            <div id="tooltip"></div>
            <section>
                <a href = "./">Documentation Home</a><br>
                <h1>The Sirius Type System</h1>
            </section>
            <section id = "whats_special">
                <h2>What's special about it?</h2>
                <p>A type system featuring refinement types can enforce properties of programs at compile time that are usually enforced with runtime errors. For example, if a type system tracks the possible values of integers, it could:</p>
                <ul>
                    <li>Detect potential overflows and divisions by zero</li>
                    <li>Check that array accesses are in-bounds</li>
                    <li>Enforce constraints on array shapes, such as the dimension requirements for matrix multiplication: <code class = "doc">AB = C</code> implies for <code class = "doc">A[X, Y]</code> and <code class = "doc">B[Y, Z]</code>, <code class = "doc">C[X, Z]</code></li>
                </ul>

                <p>Full-fledged refinement types can go much further; for instance, encoding the notion of a sorted list to verify a sorting algorithm.<sup class = "external"><a href = "https://ucsd-progsys.github.io/liquidhaskell/blogposts/2013-07-29-putting-things-in-order.lhs/">link</a></sup></p>

                <p>To realize these advantages, programmers of refinement-typed languages must specify the properties they want as types and write procedures that provably adhere to those types. For industry programmers in fields without critical correctness requirements, this may be a prohibitive amount of work.<sup class = "footnote">Even if a programmer is perfectly comfortable with refinement types, more sophisticated type systems make helpful compiler errors harder to generate and increase compile times.</sup></p>

                <p>Sirius does not accommodate user-defined refinement types. The language only supplies a single built-in family of refinable types: a multivariate integer polynomial <code class = "doc"><span class = "token identifier type">Poly</span></code>. The type checker automatically tracks all integer values in the program as <code class = "doc"><span class = "token identifier type">Poly</span></code>s on a best-effort basis. The choice of polynomial representation may seem a bit random &mdash; hopefully the examples below illustrate that it suits many use cases for array programming.<sup class = "footnote">One motivation: polynomials are closed under addition and multiplication, the two operations needed to index a multidimensional array. Suppose we are given an array <code class = "doc">A[M, N, N]</code> of square matrices. If we want the 2nd element of the 2nd row of the 3rd matrix, we compute <code class = "doc">A[2*N^2 + N + 1]</code> (of course, usually written <code class = "doc">A[2, 1, 1]</code>).</sup></p>

                <p>The type system laid out in this document accomplishes the above list of integer refinement type use cases and also unlocks potential optimizations for high-level array code.</p>
            </section>
            <section id = "basics">
                <h2>Basics</h2>
                <p>The Sirius type system has a fundamental law: no type information may flow between functions except through their signatures.<sup class = "footnote">In other words, there is no program or module-level inference, only intra-function inference. At the cost of requiring annotations, this makes it easier to reason about programs for both the programmer and the typechecker.</sup> </p>
                <p>Sirius currently supports a small set of primitive types: boolean <code class = "doc"><span class = "token type identifier">bool</span></code>, 64-bit integer <code class = "doc"><span class = "token type identifier">i64</span></code>, and 64-bit floating point <code class = "doc"><span class = "token type identifier">f64</span></code>. We can combine types as tuples or functions.</p>
                
<code class = "block please_parse">fn main():
    let a = true             // bool
    let b = 1                // i64
    let c = 0.1              // f64
    let d = example          // function f64->bool
    let e = (a, (c, d))      // tuple (bool, (f64, f64->bool))
    let f: bool = example(c) // annotations are optional inside functions

// but mandatory for function signatures
fn example(x: f64) -> bool:
    return x > 3</code>
            </section>
        </article>
    </body>
</html>