<!DOCTYPE HTML>
<html>
    <head>
        <meta charset = "UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" type="image/x-icon" href="./favicon.ico">
        <link rel = "stylesheet" href = "./css/main.css">
        <script src = "./js/docs.js" type = "module"></script>
        <title>Sirius Type System</title>
    </head>
    <body>
        <article>
            <div id="tooltip"></div>
            <section>
                <a href = "./">Documentation Home</a><br>
            </section>
            <section>
                <h1>The Sirius Type System</h1>
                <ol>
                    <li><a href = "#low_friction_refinement">Low-Friction Refinement</a></li>
                    <li><a href = "#basics">Basics</a></li>
                    <li><a href = "#systems_and_constraints">Systems and Constraints</a></li>
                    <li><a href = "#array_programming">Array Programming</a></li>
                    <li><a href = "#caveats">Caveats</a></li>
                </ol>
            </section>
            <section id = "low_friction_refinement">
                <h2>Low-Friction Refinement</h2>
                <p>A type system featuring refinement types can enforce properties of programs at compile time that are usually enforced with runtime errors. For example, if a type system tracks the possible values of integers, it could:</p>
                <ul>
                    <li>Detect potential overflows and divisions by zero</li>
                    <li>Check that array accesses are in-bounds</li>
                    <li>Enforce constraints on array shapes, such as the dimension requirements for matrix multiplication: <code class = "doc">C = AB</code> implies for <code class = "doc">A[X, Y]</code> and <code class = "doc">B[Y, Z]</code>, <code class = "doc">C[X, Z]</code></li>
                </ul>

                <p>Full-fledged refinement types can go much further; for instance, they can statically verify security policies of <a href = "https://www.usenix.org/conference/osdi21/presentation/lehmann" target = "_blank">a web application</a>.</p>

                <p>To realize these advantages, programmers of refinement-typed languages must specify the properties they want as types and write procedures that provably adhere to those types. For programmers in fields without critical correctness requirements, this may be a prohibitive amount of work.<sup class = "footnote">Dependent type systems are even more expressive than refinement alone, since verification need not be performed by an SMT solver. On the other hand, programming is hard, compiling is slow, and compiler errors for arithmetic constraint violations in particular can be "daunting in size."<sup class = "external"><a href = "https://dl.acm.org/doi/10.1145/3341704">[link]</a></sup></sup> The expressive power of refinement depends on the theories supported by the attending solver. Languages that support refinement, like <a href = "https://ucsd-progsys.github.io/liquidhaskell/" target = "_blank">Liquid Haskell</a>, also often have other powerful type features.</p>
                
                <p>Sirius instead only provides a single theory, polynomial integer arithmetic<sup class = "footnote">Unfortunately incomplete, courtesy of work on <a href = "https://en.wikipedia.org/wiki/Hilbert%27s_tenth_problem" target = "_blank">Hilbert's 10th problem</a>.</sup>, and an otherwise simple type system. We seek to limit expressiveness so that the types that <em>can</em> be expressed have extra syntactic and semantic support.<sup class = "footnote">A composer might limit themselves to a proven formula like the fugue or sonata for analogous reasons. The perfect tool to communicate a given idea has all expressiveness necessary and no more.</sup></p>

                <p>The typechecker automatically tracks all integer values in the program as multivariate integer polynomial <code class = "doc"><span class = "token identifier type">Poly</span></code>s on a best-effort basis. The choice of polynomial representation may seem arbitrary &mdash; this document will hopefully illustrate that it suits many use cases for array programming.<sup class = "footnote">One motivation to pique interest: polynomials are closed under addition and multiplication, the two operations needed to index a multidimensional array. Suppose we are given an array <code class = "doc">A[M, N, N]</code> of square matrices. If we want the 2nd element of the 2nd row of the 3rd matrix, we compute <code class = "doc">A[2*N^2 + N + 1]</code> (of course, usually written <code class = "doc">A[2, 1, 1]</code>).</sup> Encoding array sizes and accesses with <code class = "doc"><span class = "token identifier type">Poly</span></code>s also unlocks potential optimizations for high-level array code.</p>
            </section>
            <section id = "basics">
                <h2>Basics</h2>
                <p>The Sirius type system has a fundamental law: no type information may flow between functions except through their signatures. In other words, the typechecker performs inference only within function boundaries.   </p>
                <p>Sirius currently supports a small set of primitive types: boolean <code class = "doc"><span class = "token type identifier">bool</span></code>, 64-bit integer <code class = "doc"><span class = "token type identifier">i64</span></code>, and 64-bit floating point <code class = "doc"><span class = "token type identifier">f64</span></code>. We can combine types as tuples or functions.</p>
                
<code class = "block please_parse">fn main():
    let a = true             // bool
    let b = 1                // i64
    let c = 0.1              // f64
    let d = example          // function f64->bool
    let e = (a, (c, d))      // tuple (bool, (f64, f64->bool))
    let f: bool = example(c) // annotations are optional inside functions

// but mandatory for function signatures
fn example(x: f64) -> bool:
    return x > 3</code>

                <p>Type parameters may be added to functions, but all expressions must have concrete types.</p>
<code class = "block please_parse">// the type parameter list is enclosed by curly brackets 
fn double{T}(x: T) -> (T, T):
    return (x, x)

fn main():
    print double(1)
    print double{bool}(true) // as are type parameters in expressions
    print double(double{f64})</code>
                <p>Sirius tries to track all integer values as polynomials. This means we can perform arithmetic in the type system, but as soon as a value cannnot be represented as a polynomial (for instance, if it is the result of an arbitrary function call or division without an exact result), it must be given a fresh type variable.</p>     

<code class = "block please_parse">// this function returns a plain i64
fn untracked() -> i64:
    return 100

fn main():
    let x = 1                 // i64(poly = 1)    
    let y = untracked()       // i64(poly = 'a)
    let z = x + y             // i64(poly = 'a + 1)
    let w = (y^2 - 9)/(y + 3) // i64(poly = 'a - 3)</code>

                <p>We cannot perform inference with mutable variables.<sup class = "footnote">Well, <a href = "https://ieeexplore.ieee.org/document/855785" target = "_blank">we could try</a>, but it doesn't play nicely with control flow.</sup> Iterators are considered immutable for type purposes.</p>

                <code class = "block please_parse">fn main():
    let mut x = 0       // plain i64
    for i from 0 to 10: // i64(poly = 'a)
        x = x + i</code>
                
                <p></p>

            </section>
            <section id = "systems_and_constraints">
                <h2>Systems and Constraints</h2>
            </section>    
            <section id = "array_programming">
                <h2>Array Programming</h2>
            </section>
            <section id = "caveats">
                <h2>Caveats</h2>
            </section>
        </article>
    </body>
</html>