<!DOCTYPE HTML>
<html>
    <head>
        <meta charset = "UTF-8">
        <link rel="icon" type="image/x-icon" href="./favicon.ico">
        <link rel = "stylesheet" href = "./css/main.css">
        <title>Sirius</title>
    </head>
    <body>
        <article>
            <section>
                <h1>✷✶✦ Sirius ✦✶✷</h1>

                <p>Sirius is an array-oriented programming language for expressing algorithms with strong safety guarantees.</p>

                <p>These docs and the language itself are under construction. <span class = "asp">Anything written in this style is aspirational and not fully implemented.</span> Sirius in a nutshell:
                    <ul>
                        <li>Static type checking</li>
                        <li>Type inference within function boundaries</li>
                        <li>Parametric polymorphism</li>
                        <li><span class = "asp">Array-oriented facilities like broadcasting and fancy indexing</li>
                        <li><span class = "asp">Ergonomic static array access checking</span></li>
                        <li><span class = "asp">A fast GPU backend</span></li>
                        <li><span class = "asp">Python bindings and Jupyter integration</span></li>
                    </ul>
                </p>

                <p>You can try out Sirius with the <a href = "./demo.html">in-browser demo</a> or by cloning <a href = "https://github.com/lorentzj/sirius">the git repository</a>.</p>
            </section>
            
            <section id = "#contents">
                <h2>Contents</h2>
                <ol>
                    <li><a href = "#syntax">Syntax</a>
                        <ol>
                            <li><a href = "#operator_table">Operator Table</a></li>
                        </ol>
                    </li>
                    <li><a href = "#type_system">Type System</a>
                        <ol>
                            <li><a href = "#type_coercion">Coercion</a></li>
                            <li><a href = "#generic_functions">Generic Functions</a></li>
                        </ol>
                    </li>
                    <li><a href = "#standard_lib">Standard Library</a></li>
                    <li><a href = "#plans">Notes for the Future</a></li>
                </ol>
            </section>

            <section id = "syntax">
                <h2>Syntax</h2>
                <p>Sirius uses significant whitespace in the style of Python; new lines and indent/dedents separate statements and blocks. The grammar is LR(1); a more precise specification can be found <a href = "https://github.com/lorentzj/sirius/blob/main/src/grammar.lalrpop">in the reference parser</a>.</p>

                <p>A Sirius source file is a series of <em>functions</em>:</p>
                <code class = "block"><span class = "code token keyword">fn</span> <span class = "code token identifier">function_name</span><span class = "code token openparen">(</span><span class = "code token identifier">arg</span><span class = "code token colon">:</span> <em>&lt;arg type annotation&gt;</em><span class = "code token operator">,</span> ...<span class = "code token closeparen">)</span> <span class = "code token operator">-&gt;</span> <em>&lt;return type annotation&gt;</em><span class = "code token colon">:</span>
    <em><em>&lt;statements&gt;</em></em>
</code>

                <p>The return type may be omitted, in which case the function will return <code><span class = "code token identifier type">void</span></code>. There are five forms of <em>statement</em>:</p>

                <code class = "block"><span class = "code token keyword">let</span> <span class = "code token identifier">x</span><span class = "code token colon">:</span> <em>&lt;type annotation&gt;</em> <span class = "code token assign">=</span> <em>&lt;expression&gt;</em></code>
                <br>
                <code class = "block"><span class = "code token keyword">print</span> <em>&lt;expression&gt;</em></code>
                <br>
                <code class = "block"><span class = "code token keyword">return</span> <em>&lt;expression&gt;</em></code>
                <br>
                <code class = "block"><span class = "code token keyword">for</span> <span class = "code token identifier">i</span> <span class = "code token keyword">from</span> <em>&lt;expression&gt;</em> <span class = "code token keyword">to</span> <em>&lt;expression&gt;</em><span class = "code token colon">:</span>
    <em><em>&lt;statements&gt;</em></em>
</code>
                <br>
                <code class = "block"><span class = "code token keyword">if</span> <em>&lt;expression&gt;</em><span class = "code token colon">:</span>
    <em><em>&lt;statements&gt;</em></em>
<span class = "code token keyword">else</span><span class = "code token colon">:</span>
    <em><em>&lt;statements&gt;</em></em>
</code>
                <p>The <code><span class = "code token keyword">else</span></code> block of <code><span class = "code token keyword">if</span></code> statements may be omitted as usual. <code><span class = "code token keyword">let</span></code> statements may omit the type annotation.</p>

                <p>Expressions are constructed from <em>constants</em>, <em>identifiers</em>, and a set of left-associative operations upon them:</p>
                <h3 id = "operator_table">Operator Table</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Precedence</th>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>Parentheses</td>
                            <td>Unary</td>
                            <td><code><span class = "code token openparen">(</span><span class = "code token identifier">a</span><span class = "code token closeparen">)</span></code></td>
                        <tr>
                            <td>1</td>
                            <td>Application</td>
                            <td>N-ary</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token openparen">(</span><span class = "code token identifier">b</span><span class = "code token operator">,</span><span class = "code token identifier">c</span><span class = "code token closeparen">)</span></code></td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>Member Access</td>
                            <td>Binary</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">.</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>Exponent</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">^</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>Boolean Negation</td>
                            <td>Unary Boolean</td>
                            <td><code><span class = "code token operator">!</span><span class = "code token identifier">a</span></code></td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>Arithmetic Negation</td>
                            <td>Unary Arithmetic</td>
                            <td><code><span class = "code token operator">-</span><span class = "code token identifier">a</span></code></td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>Multiplication</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">*</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>Division</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">/</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>Addition</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">+</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>Subtraction</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">-</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>Greater</td>
                            <td>Binary Comparison</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">&gt;</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>Less</td>
                            <td>Binary Comparison</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">&lt;</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>Equal</td>
                            <td>Binary Comparison</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">==</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>Not Equal</td>
                            <td>Binary Comparison</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">!=</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>And</td>
                            <td>Binary Boolean</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">&&</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>Or</td>
                            <td>Binary Boolean</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">||</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>Inf</td>
                            <td>Tuple</td>
                            <td>Binary*</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">,</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                    </tbody>
                </table>

                <p>The tuple operation <code><span class = "code token operator">,</span></code> is a special case; the tuple is not constructed until enclosed in parentheses unless it is the top level of the expression in order to distinguish e.g. <code><span class = "code token openparen">(</span><span class = "code token identifier">a</span><span class = "code token operator">,</span> <span class = "code token identifier">b</span><span class = "code token operator">,</span> <span class = "code token identifier">c</span><span class = "code token closeparen">)</span></code> from <code><span class = "code token openparen">(</span><span class = "code token openparen">(</span><span class = "code token identifier">a</span><span class = "code token operator">,</span> <span class = "code token identifier">b</span><span class = "code token closeparen">)</span><span class = "code token operator">,</span> <span class = "code token identifier">c</span><span class = "code token closeparen">)</span></code>. This behavior is consistent with tuple construction in other languages.</p>

                <p>Identifiers are strings of ascii letters, greek letters, digits, and underscores, beginning with something besides a digit: <code>[A-Za-z_\u{0370}-\u{03FF}][0-9A-Za-z_\u{0370}-\u{03FF}]*</code>. Constants may be numbers, which must begin with a digit and will be parsed as floats if they contain a decimal point, and otherwise will be parsed as integers. Constants may also be the boolean values <code><span class = "code token keyword">true</span></code> and <code><span class = "code token keyword">false</span></code>.</p>

                <p>Type annotations are constructed from the primitive types using the tuple operator <code><span class = "code token operator type">,</span></code> and the function operator <code><span class = "code token operator type">-&gt;</span></code>. The function operator is binary left-associative and denotes function inputs and outputs, e.g., <code><span class = "code token identifier type">f64</span><span class = "code token operator type">-&gt;</span><span class = "code token identifier type">bool</span></code> or <code><span class = "code token openparen type">(</span><span class = "code token identifier type">f64</span><span class = "code token operator type">,</span> <span class = "code token identifier type">f64</span><span class = "code token closeparen type">)</span><span class = "code token operator type">-&gt;</span><span class = "code token identifier type">i64</span></code>.</p>
                
                <p>Comments are introduced with two forward slashes and extend to the end of the line  <code><span class = "code token comment">//like so</span></code>.</p>
            </section>

            <section id = "type_system">
                <h2>Type System</h2>
                <p>There are four primitive types in Sirius: <code><span class = "code token identifier type">f64</span></code> (a 64-bit IEEE 754 floating point number), <code><span class = "code token identifier type">i64</span></code> (a 64-bit signed integer), <code><span class = "code token identifier type">bool</span></code> (a boolean type), and <code><span class = "code token identifier type">void</span></code> (the uninhabited type). <code><span class = "code token identifier type">i64</span></code>s may have a value known at compile time, denoted e.g. <code><span class = "code token identifier type">i64(ind=0)</span></code>. All tuple accesses are statically verified.</p>

                <p>The <code><span class = "code token keyword">if</span></code> and <code><span class = "code token keyword">for</span></code> statements require their expressions to be <code><span class = "code token identifier type">bool</span></code>s and <code><span class = "code token identifier type">i64</span></code>s respectively.</p>

                <p>The compound types, tuples and functions, can be built from arbitrary combinations of any types. Functions are first-class types; a function may accept function arguments or return functions.</p>

                <p>The wildcard <code><span class = "code token type">_</span></code> may be used in type annotations and type arguments:</p>

                <code class = "block"><span class = "code token keyword">fn</span><span class = "code"> </span><span class = "code token identifier">main</span><span class = "code token openparen">(</span><span class = "code token closeparen">)</span><span class = "code token colon">:</span>
    <span class = "code"> </span><span class = "code token keyword">let</span><span class = "code"> </span><span class = "code token identifier">a</span><span class = "code token colon">:</span><span class = "code"> </span><span class = "code token openparen type">(</span><span class = "code token identifier type">f64</span><span class = "code token operator type">,</span><span class = "code"> </span><span class = "code token identifier type">_</span><span class = "code token operator type">,</span><span class = "code"> </span><span class = "code token identifier type">f64</span><span class = "code token closeparen type">)</span><span class = "code"> </span><span class = "code token assign">=</span><span class = "code"> </span><span class = "code token openparen">(</span><span class = "code token const">1.</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token const">1.</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token const">1.</span><span class = "code token closeparen">)</span></code>
                <h3 id = "type_coercion">Coercion</h3>

                <p>The binary arithmetic operations <code><span class = "code token operator">*</span></code>, <code><span class = "code token operator">/</span></code>, <code><span class = "code token operator">+</span></code>, and <code><span class = "code token operator">-</span></code>, will accept any combination of <code><span class = "code token identifier type">f64</span></code>, <code><span class = "code token identifier type">i64</span></code>, and <code><span class = "code token identifier type">bool</span></code>. If any operand is <code><span class = "code token identifier type">f64</span></code>, the result will also be <code><span class = "code token identifier type">f64</span></code>. Otherwise, the operation will evaluate to an <code><span class = "code token identifier type">i64</span></code>. <code><span class = "code token identifier type">bool</span></code> arithmetic is evaluated with <code><span class = "code token keyword">true</span></code> equal to <code><span class = "code token const">1</span></code> and <code><span class = "code token keyword">false</span></code> equal to <code><span class = "code token const">0</span></code>.</p>

                <p>The exponent operator <code><span class = "code token operator">^</span></code> will accept <code><span class = "code token identifier type">i64</span></code>s and <code><span class = "code token identifier type">bool</span></code>s as above, but will always evaluate to an <code><span class = "code token identifier type">f64</span></code>. The equality and inequality operators, <code><span class = "code token operator">==</span></code> and <code><span class = "code token operator">!=</span></code>, and the comparison operators, <code><span class = "code token operator">&gt;</span></code> and <code><span class = "code token operator">&lt;</span></code>, will coerce <code><span class = "code token identifier type">i64</span></code>s into <code><span class = "code token identifier type">f64</span></code>s. Equality and inequality coercion will apply recursively to tuple types:</p>

<code class = "block"><span class = "code token keyword">fn</span><span class = "code"> </span><span class = "code token identifier">main</span><span class = "code token openparen">(</span><span class = "code token closeparen">)</span><span class = "code token colon">:</span>
    <span class = "code token keyword">let</span><span class = "code"> </span><span class = "code token identifier">a</span><span class = "code"> </span><span class = "code token assign">=</span><span class = "code"> </span><span class = "code token openparen">(</span><span class = "code token const">1</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token const">1</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token const">1</span><span class = "code token closeparen">)</span>
    <span class = "code token keyword">let</span><span class = "code"> </span><span class = "code token identifier">b</span><span class = "code"> </span><span class = "code token assign">=</span><span class = "code"> </span><span class = "code token openparen">(</span><span class = "code token const">1.</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token const">1.</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token const">1.</span><span class = "code token closeparen">)</span>
    <span class = "code token keyword">print</span><span class = "code"> </span><span class = "code token identifier">a</span><span class = "code"> </span><span class = "code token operator">==</span><span class = "code"> </span><span class = "code token identifier">b</span></code>
<br>
<code class = "block">true</code>

            <h3 id = "generic_functions">Generic Functions</h3>
            <p>The type variables for a function signature may be listed in curly brackets before the parameters. At instantiation, a generic function may be passed type parameters using curly brackets. Wildcards are allowed as type arguments, and if fewer type arguments are provided than expected, the rest are assigned wildcards.</p>
<code class = "block"><span class = "code token keyword">fn</span><span class = "code"> </span><span class = "code token identifier">double</span><span class = "code token opencurly">{</span><span class = "code token identifier type">T</span><span class = "code token closecurly">}</span><span class = "code token openparen">(</span><span class = "code token identifier">t</span><span class = "code token colon">:</span><span class = "code"> </span><span class = "code token identifier type">T</span><span class = "code token closeparen">)</span><span class = "code"> </span><span class = "code token operator">-&gt;</span><span class = "code"> </span><span class = "code token openparen type">(</span><span class = "code token identifier type">T</span><span class = "code token operator type">,</span><span class = "code"> </span><span class = "code token identifier type">T</span><span class = "code token closeparen type">)</span><span class = "code token colon">:</span>
    <span class = "code token keyword">return</span><span class = "code"> </span><span class = "code token openparen">(</span><span class = "code token identifier">t</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token identifier">t</span><span class = "code token closeparen">)</span>

<span class = "code token keyword">fn</span><span class = "code"> </span><span class = "code token identifier">main</span><span class = "code token openparen">(</span><span class = "code token closeparen">)</span><span class = "code token colon">:</span>
    <span class = "code token keyword">print</span><span class = "code"> </span><span class = "code token identifier">double</span><span class = "code token openparen">(</span><span class = "code token const">1</span><span class = "code token closeparen">)</span>
    <span class = "code token keyword">print</span><span class = "code"> </span><span class = "code token identifier">double</span><span class = "code token openparen">(</span><span class = "code token openparen">(</span><span class = "code token keyword">false</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token keyword">true</span><span class = "code token closeparen">)</span><span class = "code token closeparen">)</span>
    <span class = "code token keyword">print</span><span class = "code"> </span><span class = "code token identifier">double</span><span class = "code token opencurly">{</span><span class = "code token identifier type">_</span><span class = "code token closecurly">}</span><span class = "code token openparen">(</span><span class = "code token openparen">(</span><span class = "code token keyword">false</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token keyword">true</span><span class = "code token closeparen">)</span><span class = "code token closeparen">)</span>
    <span class = "code token keyword">print</span><span class = "code"> </span><span class = "code token identifier">double</span><span class = "code token opencurly">{</span><span class = "code token openparen type">(</span><span class = "code token identifier type">_</span><span class = "code token operator type">,</span><span class = "code"> </span><span class = "code token identifier type">bool</span><span class = "code token closeparen type">)</span><span class = "code token closecurly">}</span><span class = "code token openparen">(</span><span class = "code token openparen">(</span><span class = "code token keyword">false</span><span class = "code token operator">,</span><span class = "code"> </span><span class = "code token keyword">true</span><span class = "code token closeparen">)</span><span class = "code token closeparen">)</span></code>
            <br>
<code class = "block">(1, 1)
((false, true), (false, true))
((false, true), (false, true))
((false, true), (false, true))
</code>

            </section>

            <section id = "standard_lib">
                <h2>Standard Library</h2>
                <p>These values are provided by the implementation and globally scoped.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code><span class = "code token identifier">pi</span></code></td>
                            <td><code><span class = "code token identifier type">f64</span></code></td>
                            <td>The constant π (pi)</td>
                        </tr>
                        <tr>
                            <td><code><span class = "code token identifier">sin</span></code></td>
                            <td><code><span class = "code token identifier type">f64<span class = "code token operator type">-&gt;</span><code class = "code token identifier type">f64</code></td>
                            <td>Trigonometric sine</td>
                        </tr>
                        <tr>
                            <td><code><span class = "code token identifier">cos</span></code></td>
                            <td><code><span class = "code token identifier type">f64<span class = "code token operator type">-&gt;</span><code class = "code token identifier type">f64</code></td>
                            <td>Trigonometric cosine</td>
                        </tr>
                        <tr>
                            <td><code><span class = "code token identifier">tan</span></code></td>
                            <td><code><span class = "code token identifier type">f64<span class = "code token operator type">-&gt;</span><code class = "code token identifier type">f64</code></td>
                            <td>Trigonometric tangent</td>
                        </tr>
                        <tr>
                            <td><code><span class = "code token identifier">ln</span></code></td>
                            <td><code><span class = "code token identifier type">f64<span class = "code token operator type">-&gt;</span><code class = "code token identifier type">f64</code></td>
                            <td>Natural log</td>
                        </tr>
                        <tr>
                            <td><code><span class = "code token identifier">log10</span></code></td>
                            <td><code><span class = "code token identifier type">f64<span class = "code token operator type">-&gt;</span><code class = "code token identifier type">f64</code></td>
                            <td>Log base 10</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            <section id = "plans">
                <h2>Notes for the Future</h2>
                    <p><em>Potential new language features must overcome a bias towards simplicity.</em></p>
                    <p>The language takes inspiration from Futhark, as well as working with arrays in Python using the likes of Numpy and PyTorch, and  array languages like APL.</p>
                    <p>Sirius is currently an experiment in the ergonomics of typeful array programming. The only existing backend is a slow interpreter for testing purposes. After the frontend becomes somewhat stable, the project will shift in focus to a new backend.</p>
                    <p>Shader SPIR-V is the current aspirational target for the fast backend, making Sirius a GPGPU kernel language, suitable for machine learning, image processing, HPC, scientific computing, or any application requiring high parallelism and strong static safety guarantees.</p>
                    <p>Typechecking array sizes and accesses costs developer time, but have substantial advantages:</p>
                    <ul>
                        <li>Function contracts will be more precise, moving more data validation from dynamic checks to automatic type checks.</li>
                        <li>Vectorization, loop unrolling, and access check elision all will be easier with the additional information from the typechecker.</li>
                        <li>Algorithmic time and space complexity can be calculated as a simple function of input sizes for subroutines, or even whole programs, depending on the use of existential types and recursion.</li>
                    </ul>
                    <p>An example function using generic <code><span class = "code token type">ind</span></code> types and a possible C compilation:</p>

<code class = "block"><span class = "code token keyword">fn</span><span class = "code"> </span><span class = "code token identifier">concat</span><span class = "code token opencurly">{</span><span class = "code token identifier type">T</span><span class = "code token operator type">,</span> <span class = "code token identifier type">#M</span><span class = "code token operator type">,</span><span class = "code"> </span><span class = "code token identifier type">#N</span><span class = "code token closecurly">}</span><span class = "code token openparen">(</span><span class = "code token identifier">a</span><span class = "code token colon">:</span><span class = "code"> </span><span class = "code token identifier type">T</span><span class = "code token opensqbracket type">[</span><span class = "code token identifier type">M</span><span class = "code token closesqbracket type">]</span><span class = "code token operator">,</span> <span class = "code token identifier">b</span><span class = "code token colon">:</span><span class = "code"> </span><span class = "code token identifier type">T</span><span class = "code token opensqbracket type">[</span><span class = "code token identifier type">N</span><span class = "code token closesqbracket type">]</span><span class = "code token closeparen">)</span> <span class = "code token operator">-&gt;</span><span class = "code"> </span><span class = "code token identifier type">T</span><span class = "code token opensqbracket type">[</span><span class = "code token identifier type">M</span> <span class = "code token operator type">+</span> <span class = "code token identifier type">N</span><span class = "code token closesqbracket type">]</span><span class = "code token colon">:</span>
    ...</code>
<br>
<code class = "block">int* concat(int m, int n, int* a, int* b) {
    int* r = malloc((m + n) * sizeof(int));
    ...
}
</code>
    <p>The language will include <code><span class = "code token type">ind</span></code> constraints and existential <code><span class = "code token type">ind</span></code>s as well:</p>
<code class = "block"><span class = "code token comment">//                           ┏ Constraint</span>
<span class = "code token comment">//                  ┏ Existential</span>
<span class = "code token comment">//            ┏ Universal    ┃</span>
<span class = "code token comment">//        ┏━━━┫    ┏┫   ┏━━━━┫</span>
<span class = "code token keyword">fn</span><span class = "code"> </span><span class = "code token identifier">filter</span><span class = "code token opencurly">{</span><span class = "code token identifier type">T</span><span class = "code token operator type">,</span> <span class = "code token identifier type">#M</span> <span class = "code token operator type">=></span><span class = "code"> </span><span class = "code token identifier type">#N</span> <span class = "code token operator type">|</span> <span class = "code token identifier type">N</span> <span class = "code token operator type">&lt;=</span> <span class = "code token identifier type">M</span><span class = "code token closecurly">}</span><span class = "code token openparen">(</span><span class = "code token identifier">x</span><span class = "code token colon">:</span><span class = "code"> </span><span class = "code token identifier type">T</span><span class = "code token opensqbracket type">[</span><span class = "code token identifier type">M</span><span class = "code token closesqbracket type">]</span><span class = "code token operator">,</span> <span class = "code token identifier">f</span><span class = "code token colon">:</span><span class = "code"> </span><span class = "code token identifier type">T</span><span class = "code token operator type">-></span><span class = "code token identifier type">bool</span><span class = "code token closeparen">)</span> <span class = "code token operator">-&gt;</span><span class = "code"> </span><span class = "code token identifier type">T</span><span class = "code token opensqbracket type">[</span><span class = "code token identifier type">N</span><span class = "code token closesqbracket type">]</span><span class = "code token colon">:</span>
    ...</code>

                <p>The <code><span class = "code token type">ind</span></code> types are multivariable integer polynomials, and so closed under addition, subtraction, and multiplication. The constraints produced by the typechecker will be checked with an SMT solver like Z3. This satisfaction problem is undecidable in general, but in practice is expected to be tractable for most cases. The solver will be able to check each function independently, and a mechanism will be provided to override the solver and move an access check to runtime.</p>

                <p>There will be three types of constraints: implicit constraints (all array sizes in the function signature most be greater than or equal to zero), explicit constraints, and flow constraints (provided by <code><span class = "code token keyword">for</span></code> loops with static bounds and <code><span class = "code token keyword">if</span></code> statements with static conditions).</p>

                <p>There will be a special <code><span class = "code token identifier">reshape</span></code> function that works similarly to numpy's reshape, only checking that the product of the input array dimensions are preserved. The type system may be flexible enough to write most operations, but if <code><span class = "code token identifier">reshape</span></code> is insufficient, the language may have to add some wildcard for matching multiple array dimensions.</p>
            </section>
        </article>
    </body>
</html>