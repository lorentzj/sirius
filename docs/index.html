<!DOCTYPE HTML>
<html>
    <head>
        <meta charset = "UTF-8">
        <link rel="icon" type="image/x-icon" href="./favicon.ico">
        <link rel = "stylesheet" href = "./css/main.css">
        <title>Sirius</title>
    </head>
    <body>
        <article>
            <section>
                <h1>✷✶✦ Sirius ✦✶✷</h1>

                <p>Sirius is an array-oriented programming language for expressing algorithms with strong safety guarantees. Its core design principle is ease-of-use: Sirius programs are easy to read, write, and maintain.</p>

                <p>These docs and the language itself are under construction. <span class = "asp">Anything written in this style is aspirational and not fully implemented.</span> Sirius in a nutshell:
                    <ul>
                        <li>C-family syntax</li>
                        <li>Pass-by-value</li>
                        <li>Static type checking</li>
                        <li>Type inference within function boundaries</li>
                        <li><span class = "asp">Array-oriented facilities like broadcasting and fancy indexing</li>
                        <li><span class = "asp">Functional facilities like lambdas and parametric polymorphism</span></li>
                        <li><span class = "asp">Ergonomic static array access checking</span></li>
                    </ul>
                </p>

                <p>You can try out Sirius with the <a href = "./demo.html">in-browser demo</a> or by cloning <a href = "https://github.com/lorentzj/sirius">the git repository</a>.</p>
            </section>
            
            <section id = "#contents">
                <h2>Contents</h2>
                <ol>
                    <li><a href = "#syntax">Syntax</a></li>
                    <li><a href = "#type_system">Type System</a></li>
                    <li><a href = "#standard_lib">Standard Library</a></li>
                </ol>
            </section>

            <section id = "syntax">
                <h2>Syntax</h2>
                <p>The Sirius syntax will be familiar to users of Rust, Typescript, and similar. The grammar is LR(1); a more precise specification can be found <a href = "https://github.com/lorentzj/sirius/blob/main/src/grammar.lalrpop">in the reference parser</a>.</p>

                <p>A Sirius source file is a series of <em>functions</em>:</p>
                <code class = "block"><span class = "code token keyword">fn</span> <span class = "code token identifier">function_name</span><span class = "code token openparen">(</span><span class = "code token identifier">arg</span><span class = "code token colon">:</span> <em>&lt;arg type annotation&gt;</em><span class = "code token operator">,</span> ...<span class = "code token closeparen">)</span><span class = "code token colon">:</span> <em>&lt;return type annotation&gt;</em> <span class = "code token opencurly">{</span>
    <em><em>&lt;statements&gt;</em></em>
<span class = "code token closecurly">}</span></code>

                <p>The return type may be omitted, in which case the function will return <code><span class = "code token identifier type">void</span></code>. There are four forms of <em>statement</em>:</p>

                <code class = "block"><span class = "code token keyword">let</span> <span class = "code token identifier">x</span><span class = "code token colon">:</span> <em>&lt;type annotation&gt;</em> <span class = "code token assign">=</span> <em>&lt;expression&gt;</em><span class = "code token semicolon">;</span></code>
                <br>
                <code class = "block"><span class = "code token keyword">print</span> <em>&lt;expression&gt;</em><span class = "code token semicolon">;</span></code>
                <br>
                <code class = "block"><span class = "code token keyword">return</span> <em>&lt;expression&gt;</em><span class = "code token semicolon">;</span></code>
                <br>
                <code class = "block"><span class = "code token keyword">if</span> <em>&lt;expression&gt;</em> <span class = "code token opencurly">{</span>
    <em><em>&lt;statements&gt;</em></em>
<span class = "code token closecurly">}</span> <span class = "code token keyword">else</span> <span class = "code token closecurly">{</span>
    <em><em>&lt;statements&gt;</em></em>
<span class = "code token closecurly">}</span></code>

                <p>The <code><span class = "code token keyword">else</span></code> block of <code><span class = "code token keyword">if</span></code> statements may be omitted as usual. <code><span class = "code token keyword">let</span></code> statements may omit the type annotation.</p>

                <p>Expressions are constructed from <em>constants</em>, <em>identifiers</em>, and a set of left-associative operations upon them:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Precedence</th>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1</td>
                            <td>Parentheses</td>
                            <td>Unary</td>
                            <td><code><span class = "code token openparen">(</span><span class = "code token identifier">a</span><span class = "code token closeparen">)</span></code></td>
                        <tr>
                            <td>1</td>
                            <td>Application</td>
                            <td>N-ary</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token openparen">(</span><span class = "code token identifier">b</span><span class = "code token operator">,</span><span class = "code token identifier">c</span><span class = "code token closeparen">)</span></code></td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>Exponent</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">^</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>Boolean Negation</td>
                            <td>Unary Boolean</td>
                            <td><code><span class = "code token operator">!</span><span class = "code token identifier">a</span></code></td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>Arithmetic Negation</td>
                            <td>Unary Arithmetic</td>
                            <td><code><span class = "code token operator">-</span><span class = "code token identifier">a</span></code></td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>Multiplication</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">*</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>Division</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">/</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>Addition</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">+</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>Subtraction</td>
                            <td>Binary Arithmetic</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">-</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>And</td>
                            <td>Binary Boolean</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">&</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>Or</td>
                            <td>Binary Boolean</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">|</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>Greater</td>
                            <td>Binary Comparison</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">&gt;</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>Less</td>
                            <td>Binary Comparison</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">&lt;</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>Equal</td>
                            <td>Binary Comparison</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">==</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>Not Equal</td>
                            <td>Binary Comparison</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">!=</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td>Tuple</td>
                            <td>Binary*</td>
                            <td><code><span class = "code token identifier">a</span><span class = "code token operator">,</span><span class = "code token identifier">b</span></code></td>
                        </tr>
                    </tbody>
                </table>

                <p>The tuple operation <code><span class = "code token operator">,</span></code> is a special case; the tuple is not constructed until enclosed in parentheses unless it is the top level of the expression in order to distinguish e.g. <code><span class = "code token openparen">(</span><span class = "code token identifier">a</span><span class = "code token operator">,</span> <span class = "code token identifier">b</span><span class = "code token operator">,</span> <span class = "code token identifier">c</span><span class = "code token closeparen">)</span></code> from <code><span class = "code token openparen">(</span><span class = "code token openparen">(</span><span class = "code token identifier">a</span><span class = "code token operator">,</span> <span class = "code token identifier">b</span><span class = "code token closeparen">)</span><span class = "code token operator">,</span> <span class = "code token identifier">c</span><span class = "code token closeparen">)</span></code>. This behavior is consistent with tuple construction in other languages.</p>


            </section>

            <section id = "type_system">
                <h2>Type System</h2>

            </section>

            <section id = "standard_lib">
                <h2>Standard Library</h2>

            </section>
        </article>
    </body>
</html>