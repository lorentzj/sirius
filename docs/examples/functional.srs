fn map{A, B, #N}(v: A[N], f: A->B): B[N] {
    for i from 0 to N {
        yield f(v[i]);
    }
}

fn filter{T, #N, #M}(v: T[N], f: T->bool): T[M] {
    for i from 0 to N {
        if f(v[i]) {
            yield v[i];
        }
    }
}

fn fold{T, #N}(init: T, v: T[N], f: (T, T)->T): T {
    let r = init;
    for i from 0 to N {
        r = f(r, v[i]);
    }

    return r;
}

fn concat{T, #N, #M}(a: T[N], b: T[M]): T[N + M] {
    for i from 0 to N {
        yield a[i];
    }

    for i from 0 to M {
        yield b[i];
    }    
}