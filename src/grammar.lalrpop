use std::collections::HashMap;

use crate::parser::{Function, Statement, Expression};
use crate::lexer::Op;

grammar(highlight_map: &mut HashMap<usize, Vec<usize>>);

pub AST: HashMap<String, Function> = {
    <fns: Fn*> => fns.into_iter().map(|func| (func.name.clone(), func)).collect()
}

pub Fn: Function = {
    "fn" <name: "identifier"> <args: FnSigParams> <return_type: (":" Expr)?>  <inner: Block> => {
        let return_type = return_type.map(|r| *r.1);

        Function {
            name,
            args,
            return_type,
            inner
        }
    }
}

FnSigParams: Vec<(String, Expression)> = {
    <start: @L> "(" <arg_list: FnSigParamsInner> ")" <end: @R> => {
        highlight_map.insert(start, vec![end - 1]);
        highlight_map.insert(end - 1, vec![start]);

        arg_list
    }
}

FnSigParamsInner: Vec<(String, Expression)> = {
    () => vec![],
    <name: "identifier"> ":" <ann: Expr> => vec![(name, *ann)],
    <mut head: FnSigParamsInner> "," <name: "identifier"> ":" <ann: Expr> => {
        head.push((name, *ann));
        head
    }
}

pub Stmt: Statement = {
    <start: @L> "let" <name: "identifier"> <ann: (":" Expr)?> "=" <val: Expr> ";" <end: @R> => {
        Statement::Let {
            start,
            name, 
            ann: ann.map(|ann| Box::new(*ann.1)),
            val,
            end
        }
    },

    <start: @L> "let" <name: "identifier"> <ann: (":" Expr)?> "=" <val: OpenTuple> ";" <end: @R> => {
        Statement::Let {
            start,
            name: name, 
            ann: ann.map(|ann| Box::new(*ann.1)),
            val: match *val {
                Expression::OpenTuple{ start, inner, end } => Box::new(Expression::Tuple{ start, inner, end }),
                _ => panic!()
            },
            end
        }
    },

    <start: @L> "print" <val: Expr> ";" <end: @R> => {
        Statement::Print{<>}
    },

    <start: @L> "print" <val: OpenTuple> <end: @R> ";" => {
        Statement::Print{ start, val: match *val {
            Expression::OpenTuple{ start, inner, end } => Box::new(Expression::Tuple{ start, inner, end }),
            _ => panic!()
        }, end }
    },

    <start: @L> "if" <cond: Expr> <inner: Block> <end: @R> => {
        Statement::If{ start, cond: match *cond {
            Expression::OpenTuple{ start, inner, end } => Box::new(Expression::Tuple{ start, inner, end }),
            _ => cond
        }, inner, end }
    },

    <start: @L> "return" <val: Expr?> ";" <end: @R> => {
        Statement::Return{<>}
    },

    <start: @L> "return" <val: OpenTuple> <end: @R> ";" => {
        Statement::Return{ start, val: match *val {
            Expression::OpenTuple{ start, inner, end } => Some(Box::new(Expression::Tuple{ start, inner, end })),
            _ => panic!()
        }, end }
    },
}

pub Block: Vec<Statement> = {
    <start: @L> "{" <inner: Stmt*> "}" <end: @R> => {
        highlight_map.insert(start, vec![end - 1]);
        highlight_map.insert(end - 1, vec![start]);
        inner
    }
}

pub Expr: Box<Expression> = {
    #[precedence(level="1")]
    <t: Term> => t,
    <start: @L> <name: "identifier"> <args: FnCallParams> <end: @R> => {
        Box::new(Expression::FnCall{<>})
    },

    #[precedence(level="2")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "." <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Dot,
        rhs,
        end
    }),

    #[precedence(level="3")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "^" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Exp,
        rhs,
        end
    }),

    #[precedence(level="4")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "*" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Mul,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "/" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Div,
        rhs,
        end
    }),

    #[precedence(level="5")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "+" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Add,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "-" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Sub,
        rhs,
        end
    }),

    #[precedence(level="6")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "&" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::And,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "|" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Or,
        rhs,
        end
    }),
    #[precedence(level="7")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> ">" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Greater,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "<" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Less,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "==" <rhs: Expr> <end: @R>  => Box::new(Expression::BinOp{
        start,
        lhs,
        op: Op::Equal,
        rhs,
        end
    })
};

FnCallParams: Vec<Expression> = {
    <start: @L> "(" <arg: Expr> ")" <end: @R> => {
        highlight_map.insert(start, vec![end - 1]);
        highlight_map.insert(end - 1, vec![start]);

        vec![*arg]
    },

    <start: @L> "(" <args: OpenTuple> ")" <end: @R> => {
        highlight_map.insert(start, vec![end - 1]);
        highlight_map.insert(end - 1, vec![start]);

        match *args {
            Expression::OpenTuple{inner, ..} => inner,
            _ => panic!()
        }
    }
}

OpenTuple: Box<Expression> = {
    <start: @L> <lhs: Expr> "," <rhs: Expr> <end: @R> => {
        match *lhs {
             Expression::OpenTuple{mut inner, ..} => {
                inner.push(*rhs);
                Box::new(Expression::OpenTuple{ start, inner, end })
             }
             _ => Box::new(Expression::OpenTuple{
                start,
                inner: vec![
                    *lhs,
                    *rhs
                ],
                end
            })
        }
    },
    <start: @L> <lhs: OpenTuple> "," <rhs: Expr> <end: @R> => {
        match *lhs {
             Expression::OpenTuple{mut inner, ..} => {
                inner.push(*rhs);
                Box::new(Expression::OpenTuple{ start, inner, end })
             }
             _ => Box::new(Expression::OpenTuple{
                start,
                inner: vec![
                    *lhs,
                    *rhs
                ],
                end
            })
        }
    }
}

Term: Box<Expression> = {
    <start: @L> <val: "true"> <end: @R> => Box::new(Expression::Bool{start, val: true, end}),
    <start: @L> <val: "false"> <end: @R> => Box::new(Expression::Bool{start, val: false, end}),
    <start: @L> <val: "float"> <end: @R> => Box::new(Expression::Float{<>}),
    <start: @L> <name: "identifier"> <end: @R> => Box::new(Expression::Identifier{<>}),
    <start: @L> "(" <inner: Expr> ")" <end: @R> => {
        highlight_map.insert(start, vec![end - 1]);
        highlight_map.insert(end - 1, vec![start]);
        match *inner {
            Expression::Bool{val, ..} => Box::new(Expression::Bool{ start, val, end }),
            Expression::Float{val, ..} => Box::new(Expression::Float{ start, val, end }),
            Expression::Identifier{name, ..} => Box::new(Expression::Identifier{ start, name, end }),
            Expression::BinOp{lhs, op, rhs, ..} => Box::new(Expression::BinOp{ start, lhs, op, rhs, end }),
            Expression::FnCall{name, args, ..} => Box::new(Expression::FnCall{ start, name, args, end }),
            Expression::OpenTuple{inner, ..} => Box::new(Expression::Tuple{ start, inner, end }),
            Expression::Tuple{inner, ..} => Box::new(Expression::Tuple{ start, inner, end }),
        }
    },
    <start: @L> "(" <inner: OpenTuple> ")" <end: @R> => {
        highlight_map.insert(start, vec![end - 1]);
        highlight_map.insert(end - 1, vec![start]);
        match *inner {
            Expression::OpenTuple{inner, ..} => Box::new(Expression::Tuple{ start, inner, end }),
            _ => panic!()
        }
    }
};

extern {
    type Location = usize;
    type Error = crate::error::Error;

    enum crate::lexer::Tok {
        "("          => crate::lexer::Tok::OpenParen,
        ")"          => crate::lexer::Tok::CloseParen,
        "{"          => crate::lexer::Tok::OpenCurly,
        "}"          => crate::lexer::Tok::CloseCurly,
        "."          => crate::lexer::Tok::Op(Op::Dot),
        "^"          => crate::lexer::Tok::Op(Op::Exp),
        "*"          => crate::lexer::Tok::Op(Op::Mul),
        "/"          => crate::lexer::Tok::Op(Op::Div),
        "+"          => crate::lexer::Tok::Op(Op::Add),
        "-"          => crate::lexer::Tok::Op(Op::Sub),
        "&"          => crate::lexer::Tok::Op(Op::And),
        "|"          => crate::lexer::Tok::Op(Op::Or),
        ">"          => crate::lexer::Tok::Op(Op::Greater),
        "<"          => crate::lexer::Tok::Op(Op::Less),
        "=="         => crate::lexer::Tok::Op(Op::Equal),
        ","          => crate::lexer::Tok::Op(Op::Comma),
        "float"      => crate::lexer::Tok::Float(<f64>),
        "identifier" => crate::lexer::Tok::Identifier(<String>),
        "let"        => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Let),
        "print"      => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Print),
        "if"         => crate::lexer::Tok::Keyword(crate::lexer::Keyword::If),
        "true"       => crate::lexer::Tok::Keyword(crate::lexer::Keyword::True),
        "false"      => crate::lexer::Tok::Keyword(crate::lexer::Keyword::False),
        "fn"         => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Fn),
        "return"     => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Return),
        "="          => crate::lexer::Tok::Assign,
        ";"          => crate::lexer::Tok::Semicolon,
        ":"          => crate::lexer::Tok::Colon,
        "error"      => crate::lexer::Tok::Error(<String>),
    }
}