use std::collections::{HashMap};
use std::rc::Rc;

use crate::lexer::Op;
use crate::parser::{Function, Statement, E, Expression, UnaryOp, Positioned, expr_to_pos_type};
use crate::typechecker::Type;
use crate::solver::poly::Poly;
use crate::error::Error;

grammar(highlight_map: &mut HashMap<usize, Vec<usize>>, type_tokens: &mut Vec<usize>, errors: &mut Vec<Error>);

pub AST: HashMap<String, Function> = {
    <fns: Fn*> "newline" * => fns.into_iter().map(|func| (func.name.inner.clone(), func)).collect()
}

pub Fn: Function = {
    "newline" * "fn" <name_place: @L> <name: "identifier"> <type_args: FnTypeParams?> <args: FnSigParams> <ret_place: @L> <return_type: ("->" Expr)?> ":" "newline" <inner: Block> => {
        if let Some(return_type) = &return_type {
            let curr_type_tokens: Vec<usize> = (return_type.1.start..return_type.1.end).collect();
            type_tokens.extend(curr_type_tokens);    
        }

        let return_type = return_type.map(|r| match expr_to_pos_type(&*r.1) {
            Ok(t) => Positioned::new(t.start, Rc::new(t.inner), t.end),
            Err(error) => {
                errors.push(error);
                Positioned::new(r.1.start, Rc::new(Type::Unknown), r.1.end)
            }
        });

        let mut args_typed = vec![];

        for (arg_name, arg_ann) in args {
            let curr_type_tokens: Vec<usize> = (arg_ann.start..arg_ann.end).collect();
            type_tokens.extend(curr_type_tokens);

            args_typed.push((arg_name, match expr_to_pos_type(&arg_ann) {
                Ok(t) => t,
                Err(error) => {
                    errors.push(error);
                    Positioned::new(arg_ann.start, Type::Unknown, arg_ann.end)
                }
            }));
        }

        Function {
            name: Positioned::new(name_place, name, name_place + 1),
            type_args: type_args.unwrap_or(vec![]),
            args: args_typed,
            return_type: return_type.unwrap_or(Positioned::new(ret_place, Rc::new(Type::Void), ret_place + 1)),
            body: (inner, vec![]),
        }
    }
}

FnSigParams: Vec<(Positioned<String>, Expression)> = {
    <start: @L> "(" <arg_list: FnSigParamsInner> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        arg_list
    }
}

FnSigParamsInner: Vec<(Positioned<String>, Expression)> = {
    () => vec![],
    <start: @L> <name: "identifier"> <end: @R> ":" <ann: Expr> => vec![(Positioned::new(start, name, end), *ann)],
    <mut head: FnSigParamsInner> "," <start: @L> <name: "identifier"> <end: @R> ":" <ann: Expr> => {
        head.push((Positioned::new(start, name, end), *ann));
        head
    }
}

FnTypeParams: Vec<Positioned<String>> = {
    <start: @L> "{" <params: FnTypeParamsInner> "}" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        params
    }
}

FnTypeParamsInner: Vec<Positioned<String>> = {
    () => vec![],
    <start: @L> <name: "identifier"> <end: @R> => {
        let curr_type_tokens: Vec<usize> = (start..end).collect();
        type_tokens.extend(curr_type_tokens);

        vec![Positioned::new(start, name, end)]
    },
    <mut head: FnTypeParamsInner> "," <start: @L> <name: "identifier"> <end: @R> => {
        let curr_type_tokens: Vec<usize> = (start..end).collect();
        type_tokens.extend(curr_type_tokens);

        head.push(Positioned::new(start, name, end));
        head
    }
}

pub Block: Vec<Statement> = {
    "newline" * "indent" <inner: Stmt*> "newline" * "dedent" => {
        inner
    }
}

pub Stmt: Statement = {
    "newline" * "let" <m: "mut"?> <start: @L> <name: "identifier"> <end: @R> <ann: (":" Expr)?> "=" <val: Expr> "newline" => {
        if let Some((_, e)) = &ann {
            let curr_type_tokens: Vec<usize> = (e.start..e.end).collect();
            type_tokens.extend(curr_type_tokens);
        }
        
        let ann = ann.map(|(_, e)| match expr_to_pos_type(&*e) {
            Ok(t) => Positioned::new(t.start, Rc::new(t.inner), t.end),
            Err(error) => {
                errors.push(error);
                Positioned::new(e.start, Rc::new(Type::Unknown), e.end)
            }            
        });

        Statement::new_let(
            Positioned::new(start, name, end),
            m.is_some(),
            ann,
            *val    
        )
    },

    "newline" * "let" <m: "mut"?> <start: @L> <name: "identifier"> <end: @R> <ann: (":" Expr)?> "=" <val: OpenTuple> "newline" => {
        if let Some((_, e)) = &ann {
            let curr_type_tokens: Vec<usize> = (e.start..e.end).collect();
            type_tokens.extend(curr_type_tokens);
        }

        let ann = ann.map(|(_, e)| match expr_to_pos_type(&*e) {
            Ok(t) => Positioned::new(t.start, Rc::new(t.inner), t.end),
            Err(error) => {
                errors.push(error);
                Positioned::new(e.start, Rc::new(Type::Unknown), e.end)
            }
        });
        
        Statement::new_let(
            Positioned::new(start, name, end),
            m.is_some(),
            ann,
            match val.data {
                E::OpenTuple(inner) => {
                    *Expression::fresh(val.start, E::Tuple(inner), val.end)
                },
                _ => unreachable!()
            }
        )
    },

    "newline" * <place: Place> "=" <val: Expr> "newline" => {
        Statement::new_assign(place, *val)
    },

    "newline" * "print" <val: Expr> "newline" => {
        Statement::new_print(*val)
    },

    "newline" * "print" <val: OpenTuple> "newline" => {
        Statement::new_print(match val.data {
            E::OpenTuple(inner) => *Expression::fresh(val.start, E::Tuple(inner), val.end),
            _ => unreachable!()
        })
    },

    "newline" * "return" <val: Expr> "newline" => {
        Statement::new_return(val.start, Some(*val))
    },

    "newline" * "return" <val: OpenTuple> "newline" <end: @R> => {
        Statement::new_return(val.start, Some(match val.data {
            E::OpenTuple(inner) => *Expression::fresh(val.start, E::Tuple(inner), val.end),
            _ => unreachable!()
        }))
    },

    "newline" * <start: @L> "return" "newline" => {
        Statement::new_return(start, None)
    },

    "newline" * <start: @L> "if" <cond: Expr> ":" "newline" <true_inner: Block> <false_inner: ("else" ":" "newline" Block)?> <end: @R> => {
        let false_inner = false_inner.map(|(_, _, _, b)| b);

        let calculated_end = if let Some(false_inner) = &false_inner {
            if let Some(stmt) = false_inner.last() {
                stmt.end
            } else {
                end
            }
        } else {
            if let Some(stmt) = true_inner.last() {
                stmt.end
            } else {
                end
            }
        };

        Statement::new_if(
            start,
            *cond,
            true_inner,
            false_inner,
            calculated_end
        )
    },

    "newline" * <start: @L> "for" <start_it: @L> <iterator: "identifier"> <end_it: @L> "from" <from: Expr> "to" <to: Expr> ":" "newline" <inner: Block> <end: @R> => {
        let calculated_end = if let Some(stmt) = inner.last() {
            stmt.end
        } else {
            end
        };

        Statement::new_for(
            start,
            Positioned::new(start_it, iterator, end_it),
            *from,
            *to,
            inner,
            calculated_end
        )
    },
}

Place: Positioned<String> = {
    <start: @L> <name: "identifier"> <end: @R> => Positioned::new(start, name, end)
}

pub Expr: Box<Expression> = {
    #[precedence(level="1")]
    <t: Term> => t,

    #[precedence(level="2")] #[assoc(side="left")]
    <start: @L> <caller: Expr> <args: FnCallParams> <end: @R> => Expression::fresh(start, E::FnCall(caller, args), end),
    <start: @L> <lhs: Expr> <rhs: Array> <end: @R>            => Expression::fresh(start, E::Accessor(lhs, rhs), end),
    <start: @L> <lhs: Expr> "." <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::Dot, rhs), end),

    #[precedence(level="3")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "^" <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::Exp, rhs), end),
    
    #[precedence(level="4")] #[assoc(side="left")]
    <start: @L> <inner: Expr> "'" <end: @R>                   => Expression::fresh(start, E::UnaryOp(UnaryOp::Tick, inner), end),

    #[precedence(level="5")] #[assoc(side="left")]
    <start: @L> "!" <inner: Expr> <end: @R>                   => Expression::fresh(start, E::UnaryOp(UnaryOp::BoolNeg, inner), end),
    <start: @L> "-" <inner: Expr> <end: @R>                   => Expression::fresh(start, E::UnaryOp(UnaryOp::ArithNeg, inner), end),

    #[precedence(level="6")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "*" <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::Mul, rhs), end),
    <start: @L> <lhs: Expr> "/" <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::Div, rhs), end),

    #[precedence(level="7")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "+" <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::Add, rhs), end),
    <start: @L> <lhs: Expr> "-" <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::Sub, rhs), end),

    #[precedence(level="8")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> ">" <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::Greater, rhs), end),
    <start: @L> <lhs: Expr> "<" <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::Less, rhs), end),
    <start: @L> <lhs: Expr> ">" "=" <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::GreaterOrEq, rhs), end),
    <start: @L> <lhs: Expr> "<" "=" <rhs: Expr> <end: @R>         => Expression::fresh(start, E::BinaryOp(lhs, Op::LessOrEq, rhs), end),
    <start: @L> <lhs: Expr> "==" <rhs: Expr> <end: @R>        => Expression::fresh(start, E::BinaryOp(lhs, Op::Equal, rhs), end),
    <start: @L> <lhs: Expr> "!" "=" <rhs: Expr> <end: @R>     => Expression::fresh(start, E::BinaryOp(lhs, Op::NotEqual, rhs), end),

    #[precedence(level="9")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "&" "&" <rhs: Expr> <end: @R>     => Expression::fresh(start, E::BinaryOp(lhs, Op::And, rhs), end),
    <start: @L> <lhs: Expr> "|" "|" <rhs: Expr> <end: @R>     => Expression::fresh(start, E::BinaryOp(lhs, Op::Or, rhs), end),
    <start: @L> <lhs: Expr> "->" <rhs: Expr> <end: @R>        => Expression::fresh(start, E::BinaryOp(lhs, Op::Apply, rhs), end)
};

FnCallParams: Vec<Expression> = {
    <start: @L> "(" ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        vec![]
    },

    <start: @L> "(" <arg: Expr> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        vec![*arg]
    },

    <start: @L> "(" <args: OpenTuple> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        match args.data {
            E::OpenTuple(inner) => inner,
            _ => unreachable!()
        }
    }
}

Array: Box<Expression> = {
    <start: @L> "[" <inner: Expr> "]" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        inner
    },

    <start: @L> "[" <inner: OpenTuple> "]" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        match inner.data {
            E::OpenTuple(inner) => Expression::fresh(
                start,
                E::Tuple(inner),
                end
            ),
            _ => unreachable!()
        }
    },
}

OpenTuple: Box<Expression> = {
    <start: @L> <lhs: Expr> "," <rhs: Expr> <end: @R> => {
        match lhs.data {
             E::OpenTuple(mut inner) => {
                inner.push(*rhs);
                Expression::fresh(start, E::OpenTuple(inner), end)
             }
             _ => Expression::fresh(start, E::OpenTuple(vec![*lhs, *rhs]), end)
        }
    },
    <start: @L> <lhs: OpenTuple> "," <rhs: Expr> <end: @R> => {
        match lhs.data {
             E::OpenTuple(mut inner) => {
                inner.push(*rhs);
                Expression::fresh(start, E::OpenTuple(inner), end)
             }
             _ => Expression::fresh(start, E::OpenTuple(vec![*lhs, *rhs]), end)
        }
    }
}

IdentifierTypeParams: Vec<Expression> = {
    <start: @L> "{" "}" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        vec![]
    },

    <start: @L> "{" <arg: Expr> "}" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        let curr_type_tokens: Vec<usize> = (arg.start..arg.end).collect();
        type_tokens.extend(curr_type_tokens);

        vec![*arg]
    },

    <start: @L> "{" <args: OpenTuple> "}" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        match args.data {
            E::OpenTuple(inner) => {
                for expr in &inner {
                    let curr_type_tokens: Vec<usize> = (expr.start..expr.end).collect();
                    type_tokens.extend(curr_type_tokens);        
                }
                inner
            }
            _ => unreachable!()
        }
    }
}

Term: Box<Expression> = {
    <start: @L> "true" <end: @R> =>         Expression::fresh(start, E::Bool(true), end),
    <start: @L> "false" <end: @R> =>        Expression::fresh(start, E::Bool(false), end),
    <start: @L> <val: "float"> <end: @R> => Expression::fresh(start, E::F64(val), end),
    <start: @L> <val: "int"> <end: @R> =>   Expression::fresh(start, E::I64(val, Poly::constant(val)), end),

    <start: @L> <name: "identifier"> <type_args: IdentifierTypeParams?> <end: @R>
        => Expression::fresh(start, E::Ident(name, type_args.map(|type_args|
            type_args.iter().map(|type_arg| match expr_to_pos_type(type_arg) {
                Ok(t) => t,
                Err(error) => {
                    errors.push(error);
                    Positioned::new(type_arg.start, Type::Unknown, type_arg.end)
                }
            }).collect()
        )), end),
    
    <start: @L> "(" ")" <end: @R> => Expression::fresh(start, E::Tuple(vec![]), end),

    <start: @L> "(" <mut inner: Expr> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        inner.start = start;
        inner.end = end;
        inner
    },
    <start: @L> "(" <inner: OpenTuple> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);
        match inner.data {
            E::OpenTuple(inner) => Expression::fresh(
                start,
                E::Tuple(inner),
                end
            ),
            _ => unreachable!()
        }
    }
};

extern {
    type Location = usize;
    type Error = crate::error::Error;

    enum crate::lexer::Tok {
        "("          => crate::lexer::Tok::OpenParen,
        ")"          => crate::lexer::Tok::CloseParen,
        "{"          => crate::lexer::Tok::OpenCurly,
        "}"          => crate::lexer::Tok::CloseCurly,
        "["          => crate::lexer::Tok::OpenSqBracket,
        "]"          => crate::lexer::Tok::CloseSqBracket,
        "newline"    => crate::lexer::Tok::NewLine,
        "indent"     => crate::lexer::Tok::Indent,
        "dedent"     => crate::lexer::Tok::Dedent,        
        "."          => crate::lexer::Tok::Op(Op::Dot),
        "^"          => crate::lexer::Tok::Op(Op::Exp),
        "'"          => crate::lexer::Tok::Op(Op::Tick),
        "*"          => crate::lexer::Tok::Op(Op::Mul),
        "/"          => crate::lexer::Tok::Op(Op::Div),
        "+"          => crate::lexer::Tok::Op(Op::Add),
        "-"          => crate::lexer::Tok::Op(Op::Sub),
        "&"          => crate::lexer::Tok::Op(Op::And),
        "|"          => crate::lexer::Tok::Op(Op::Or),
        "!"          => crate::lexer::Tok::Op(Op::Not),
        ">"          => crate::lexer::Tok::Op(Op::Greater),
        "<"          => crate::lexer::Tok::Op(Op::Less),
        "=="         => crate::lexer::Tok::Op(Op::Equal),
        "->"         => crate::lexer::Tok::Op(Op::Apply),
        ","          => crate::lexer::Tok::Op(Op::Comma),
        "float"      => crate::lexer::Tok::Float(<f64>),
        "int"        => crate::lexer::Tok::Int(<i64>),
        "identifier" => crate::lexer::Tok::Identifier(<String>),
        "let"        => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Let),
        "print"      => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Print),
        "if"         => crate::lexer::Tok::Keyword(crate::lexer::Keyword::If),
        "else"       => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Else),
        "true"       => crate::lexer::Tok::Keyword(crate::lexer::Keyword::True),
        "false"      => crate::lexer::Tok::Keyword(crate::lexer::Keyword::False),
        "fn"         => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Fn),
        "for"        => crate::lexer::Tok::Keyword(crate::lexer::Keyword::For),
        "from"       => crate::lexer::Tok::Keyword(crate::lexer::Keyword::From),
        "to"         => crate::lexer::Tok::Keyword(crate::lexer::Keyword::To),
        "return"     => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Return),
        "yield"      => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Yield),
        "mut"        => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Mut),
        "="          => crate::lexer::Tok::Assign,
        ";"          => crate::lexer::Tok::Semicolon,
        ":"          => crate::lexer::Tok::Colon,
        "error"      => crate::lexer::Tok::Error(<String>),
    }
}