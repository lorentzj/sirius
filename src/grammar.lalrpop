use std::collections::HashMap;

use crate::parser::{Function, Statement, Expression, UnaryOp};
use crate::lexer::Op;

grammar(highlight_map: &mut HashMap<usize, Vec<usize>>);

pub AST: HashMap<String, Function> = {
    <fns: Fn*> "newline" * => fns.into_iter().map(|func| (func.name.clone(), func)).collect()
}

pub Fn: Function = {
    "newline" * "fn" <name: "identifier"> <type_args: FnTypeParams?> <args: FnSigParams> <return_type: ("->" Expr)?> ":" "newline" <inner: Block> => {
        let return_type = return_type.map(|r| *r.1);
        let (type_args, type_arg_range) = match type_args {
            Some((a, b)) => (a, Some(b)),
            None => (vec![], None)
        };

        Function {
            name,
            type_args,
            type_arg_range,
            args,
            return_type,
            inner
        }
    }
}

FnSigParams: Vec<(String, Expression)> = {
    <start: @L> "(" <arg_list: FnSigParamsInner> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        arg_list
    }
}

FnSigParamsInner: Vec<(String, Expression)> = {
    () => vec![],
    <name: "identifier"> ":" <ann: Expr> => vec![(name, *ann)],
    <mut head: FnSigParamsInner> "," <name: "identifier"> ":" <ann: Expr> => {
        head.push((name, *ann));
        head
    }
}

FnTypeParams: (Vec<String>, (usize, usize)) = {
    <start: @L> "{" <params: FnTypeParamsInner> "}" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        (params, (start + 1, end - 1))
    }
}

FnTypeParamsInner: Vec<String> = {
    () => vec![],
    <name: "identifier"> => vec![name],
    <mut head: FnTypeParamsInner> "," <name: "identifier"> => {
        head.push(name);
        head
    }
}

pub Stmt: Statement = {
    "newline" * <start: @L> "let" <name: "identifier"> <ann: (":" Expr)?> "=" <val: Expr> "newline" <end: @R> => {
        Statement::Let {
            start,
            name, 
            ann: ann.map(|ann| Box::new(*ann.1)),
            val,
            end
        }
    },

    "newline" * <start: @L> "let" <name: "identifier"> <ann: (":" Expr)?> "=" <val: OpenTuple> "newline" <end: @R> => {
        Statement::Let {
            start,
            name: name, 
            ann: ann.map(|ann| Box::new(*ann.1)),
            val: match *val {
                Expression::OpenTuple{ start, inner, end } => Box::new(Expression::Tuple{ start, inner, end }),
                _ => panic!()
            },
            end
        }
    },

    "newline" * <start: @L> "print" <val: Expr> "newline" <end: @R> => {
        Statement::Print{<>}
    },

    "newline" * <start: @L> "print" <val: OpenTuple> "newline" <end: @R> => {
        Statement::Print{ start, val: match *val {
            Expression::OpenTuple{ start, inner, end } => Box::new(Expression::Tuple{ start, inner, end }),
            _ => panic!()
        }, end }
    },

    "newline" * <start: @L> "if" <cond: Expr> ":" "newline" <true_inner: Block> <false_inner: ("else" ":" "newline" Block)?> <end: @R> => {
        Statement::If{ start, cond: match *cond {
            Expression::OpenTuple{ start, inner, end } => Box::new(Expression::Tuple{ start, inner, end }),
            _ => cond
        }, true_inner, false_inner: false_inner.map(|(_, _, _, b)| b), end }
    },

    "newline" * <start: @L> "for" <iterator: "identifier"> "from" <from: Expr> "to" <to: Expr> ":" "newline" <inner: Block> <end: @R> => {
        Statement::For{<>}
    },

    "newline" * <start: @L> "return" <val: Expr?> "newline" <end: @R> => {
        Statement::Return{<>}
    },

    "newline" * <start: @L> "return" <val: OpenTuple> "newline" <end: @R> => {
        Statement::Return{ start, val: match *val {
            Expression::OpenTuple{ start, inner, end } => Some(Box::new(Expression::Tuple{ start, inner, end })),
            _ => panic!()
        }, end }
    },
}

pub Block: Vec<Statement> = {
    <start: @L> "newline" * "indent" <inner: Stmt*> "newline" * "dedent" <end: @R> => {
        inner
    }
}

pub Expr: Box<Expression> = {
    #[precedence(level="1")]
    <t: Term> => t,
    <start: @L> <caller: Expr> <args: FnCallParams> <end: @R> => {
        Box::new(Expression::FnCall{<>})
    },

    <start: @L> <lhs: Expr> <rhs: Array> <end: @R> => {
        Box::new(Expression::Accessor{<>})
    },

    #[precedence(level="2")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "." <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Dot,
        rhs,
        end
    }),

    #[precedence(level="3")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "^" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Exp,
        rhs,
        end
    }),

    #[precedence(level="3")] #[assoc(side="left")]
    <start: @L> <inner: Expr> "'" <end: @R>  => Box::new(Expression::UnaryOp{
        start,
        inner,
        op: UnaryOp::Tick,
        end
    }),

    #[precedence(level="4")] #[assoc(side="left")]
    <start: @L> "!" <inner: Expr> <end: @R>  => Box::new(Expression::UnaryOp{
        start,
        op: UnaryOp::BoolNeg,
        inner,
        end
    }),
    <start: @L> "-" <inner: Expr> <end: @R>  => Box::new(Expression::UnaryOp{
        start,
        op: UnaryOp::ArithNeg,
        inner,
        end
    }),

    #[precedence(level="5")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "*" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Mul,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "/" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Div,
        rhs,
        end
    }),

    #[precedence(level="6")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "+" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Add,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "-" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Sub,
        rhs,
        end
    }),

    #[precedence(level="7")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> ">" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Greater,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "<" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Less,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "==" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Equal,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "!" "=" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::NotEqual,
        rhs,
        end
    }),

    #[precedence(level="8")] #[assoc(side="left")]
    <start: @L> <lhs: Expr> "&" "&" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::And,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "|" "|" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Or,
        rhs,
        end
    }),
    <start: @L> <lhs: Expr> "->" <rhs: Expr> <end: @R>  => Box::new(Expression::BinaryOp{
        start,
        lhs,
        op: Op::Apply,
        rhs,
        end
    }),
};

Array: Box<Expression> = {
    <start: @L> "[" <inner: Expr> "]" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        inner
    },

    <start: @L> "[" <inner: OpenTuple> "]" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        match *inner {
            Expression::OpenTuple{inner, ..} => Box::new(Expression::Tuple { start, inner, end }),
            _ => panic!()
        }
    },
}

IdentifierTypeParams: (Vec<Expression>, (usize, usize)) = {
    <start: @L> "{" "}" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        (vec![], (start + 1, end - 1))
    },

    <start: @L> "{" <arg: Expr> "}" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        (vec![*arg], (start + 1, end - 1))
    },

    <start: @L> "{" <args: OpenTuple> "}" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        match *args {
            Expression::OpenTuple{inner, ..} => (inner, (start + 1, end - 1)),
            _ => panic!()
        }
    }
}


FnCallParams: Vec<Expression> = {
    <start: @L> "(" ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        vec![]
    },

    <start: @L> "(" <arg: Expr> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        vec![*arg]
    },

    <start: @L> "(" <args: OpenTuple> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);

        match *args {
            Expression::OpenTuple{inner, ..} => inner,
            _ => panic!()
        }
    }
}

OpenTuple: Box<Expression> = {
    <start: @L> <lhs: Expr> "," <rhs: Expr> <end: @R> => {
        match *lhs {
             Expression::OpenTuple{mut inner, ..} => {
                inner.push(*rhs);
                Box::new(Expression::OpenTuple{ start, inner, end })
             }
             _ => Box::new(Expression::OpenTuple{
                start,
                inner: vec![
                    *lhs,
                    *rhs
                ],
                end
            })
        }
    },
    <start: @L> <lhs: OpenTuple> "," <rhs: Expr> <end: @R> => {
        match *lhs {
             Expression::OpenTuple{mut inner, ..} => {
                inner.push(*rhs);
                Box::new(Expression::OpenTuple{ start, inner, end })
             }
             _ => Box::new(Expression::OpenTuple{
                start,
                inner: vec![
                    *lhs,
                    *rhs
                ],
                end
            })
        }
    }
}

Term: Box<Expression> = {
    <start: @L> <val: "true"> <end: @R> => Box::new(Expression::Bool{start, val: true, end}),
    <start: @L> <val: "false"> <end: @R> => Box::new(Expression::Bool{start, val: false, end}),
    <start: @L> <val: "float"> <end: @R> => Box::new(Expression::F64{<>}),
    <start: @L> <val: "int"> <end: @R> => Box::new(Expression::I64{<>}),
    <start: @L> <name: "identifier"> <type_args: IdentifierTypeParams?> <end: @R> => Box::new(Expression::Identifier{<>}),
    <start: @L> "(" ")" <end: @R> => {
        Box::new(Expression::Tuple{ start, inner: vec![], end })
    },
    <start: @L> "(" <inner: Expr> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);
        match *inner {
            Expression::Bool{val, ..} => Box::new(Expression::Bool{ start, val, end }),
            Expression::F64{val, ..} => Box::new(Expression::F64{ start, val, end }),
            Expression::I64{val, ..} => Box::new(Expression::I64{ start, val, end }),
            Expression::Identifier{name, type_args, ..} => Box::new(Expression::Identifier{ start, name, type_args, end }),
            Expression::BinaryOp{lhs, op, rhs, ..} => Box::new(Expression::BinaryOp{ start, lhs, op, rhs, end }),
            Expression::UnaryOp{op, inner, ..} => Box::new(Expression::UnaryOp{ start, op, inner, end }),
            Expression::FnCall{caller, args, ..} => Box::new(Expression::FnCall{ start, caller, args, end }),
            Expression::OpenTuple{inner, ..} => Box::new(Expression::Tuple{ start, inner, end }),
            Expression::Accessor{lhs, rhs, ..} => Box::new(Expression::Accessor{ start, lhs, rhs, end }),
            Expression::Tuple{inner, ..} => Box::new(Expression::Tuple{ start, inner, end }),
        }
    },
    <start: @L> "(" <inner: OpenTuple> ")" <end: @R> => {
        highlight_map.insert(start, vec![start, end - 1]);
        highlight_map.insert(end - 1, vec![start, end - 1]);
        match *inner {
            Expression::OpenTuple{inner, ..} => Box::new(Expression::Tuple{ start, inner, end }),
            _ => panic!()
        }
    }
};

extern {
    type Location = usize;
    type Error = crate::error::Error;

    enum crate::lexer::Tok {
        "("          => crate::lexer::Tok::OpenParen,
        ")"          => crate::lexer::Tok::CloseParen,
        "{"          => crate::lexer::Tok::OpenCurly,
        "}"          => crate::lexer::Tok::CloseCurly,
        "["          => crate::lexer::Tok::OpenSqBracket,
        "]"          => crate::lexer::Tok::CloseSqBracket,
        "newline"    => crate::lexer::Tok::NewLine,
        "indent"     => crate::lexer::Tok::Indent,
        "dedent"     => crate::lexer::Tok::Dedent,        
        "."          => crate::lexer::Tok::Op(Op::Dot),
        "^"          => crate::lexer::Tok::Op(Op::Exp),
        "'"          => crate::lexer::Tok::Op(Op::Tick),
        "*"          => crate::lexer::Tok::Op(Op::Mul),
        "/"          => crate::lexer::Tok::Op(Op::Div),
        "+"          => crate::lexer::Tok::Op(Op::Add),
        "-"          => crate::lexer::Tok::Op(Op::Sub),
        "&"          => crate::lexer::Tok::Op(Op::And),
        "|"          => crate::lexer::Tok::Op(Op::Or),
        "!"          => crate::lexer::Tok::Op(Op::Not),
        ">"          => crate::lexer::Tok::Op(Op::Greater),
        "<"          => crate::lexer::Tok::Op(Op::Less),
        "=="         => crate::lexer::Tok::Op(Op::Equal),
        "->"         => crate::lexer::Tok::Op(Op::Apply),
        ","          => crate::lexer::Tok::Op(Op::Comma),
        "float"      => crate::lexer::Tok::Float(<f64>),
        "int"        => crate::lexer::Tok::Int(<i64>),
        "identifier" => crate::lexer::Tok::Identifier(<String>),
        "let"        => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Let),
        "print"      => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Print),
        "if"         => crate::lexer::Tok::Keyword(crate::lexer::Keyword::If),
        "else"       => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Else),
        "true"       => crate::lexer::Tok::Keyword(crate::lexer::Keyword::True),
        "false"      => crate::lexer::Tok::Keyword(crate::lexer::Keyword::False),
        "fn"         => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Fn),
        "for"        => crate::lexer::Tok::Keyword(crate::lexer::Keyword::For),
        "from"       => crate::lexer::Tok::Keyword(crate::lexer::Keyword::From),
        "to"         => crate::lexer::Tok::Keyword(crate::lexer::Keyword::To),
        "return"     => crate::lexer::Tok::Keyword(crate::lexer::Keyword::Return),
        "="          => crate::lexer::Tok::Assign,
        ";"          => crate::lexer::Tok::Semicolon,
        ":"          => crate::lexer::Tok::Colon,
        "error"      => crate::lexer::Tok::Error(<String>),
    }
}